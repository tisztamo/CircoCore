var documenterSearchIndex = {"docs":
[{"location":"troubleshooting/#Troubleshooting-1","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"CircoCore is in early alpha stage. Several stability issues are known. Please file an issue if you cannot find the workaround here!","category":"page"},{"location":"troubleshooting/#The-frontend-fails-to-display-the-correct-number-of-schedulers-1","page":"Troubleshooting","title":"The frontend fails to display the correct number of schedulers","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Open the JavaScript console (F12) and reload the page. You should see exactly one connection error message, and for every scheduler a log about \"actor registration\". If not, then","category":"page"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"You may need to restart your browser\nPossibly some schedulers remained alive from a previous run","category":"page"},{"location":"troubleshooting/#Stopping-the-scheduler-processes-1","page":"Troubleshooting","title":"Stopping the scheduler processes","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"You can stop circonode.sh and localcluster.sh by pressing Crtl-C (SIGINT). In the cluster case some processes may not get stopped. Please check this with ps and kill them if needed.","category":"page"},{"location":"install/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Requirements-1","page":"Installation","title":"Requirements","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"Linux or OSX \nJulia >= v\"1.4\" download\ngit (Tested with \"version 2.17.1\") download\nNode.js (Tested with \"v12.4.0\") download - For the optional frontend","category":"page"},{"location":"install/#Install-and-run-a-sample-1","page":"Installation","title":"Install & run a sample","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"You need to checkout two repos: The CircoCore \"backend\" and the CircoCore.js \"frontend\".","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"In terminal #1 (backend)","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"git clone https://github.com/tisztamo/CircoCore.git\ncd CircoCore/\njulia --project -e 'using Pkg;Pkg.instantiate()'\nNODE_COUNT=6 bin/localcluster.sh","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"This starts a local cluster with six nodes running the sample project.","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"In terminal #2 (monitoring frontend, optional)","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"git clone https://github.com/tisztamo/CircoCore.js.git\ncd CircoCore.js\nnpm install\nnpx ws","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"This starts a web server on port 8000. Open http://localhost:8000","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [CircoCore]","category":"page"},{"location":"reference/#CircoCore.AbstractActor","page":"Reference","title":"CircoCore.AbstractActor","text":"abstract type AbstractActor\n\nSupertype of all actors.\n\nSubtypes must be mutable and must provide a field core::CoreState that can remain undefined after creation.\n\nExamples\n\nmutable struct DataHolder{TValue} <: AbstractActor\n    value::TValue\n    core::CoreState\n    DataHolder(value) = new{typeof(value)}(value)\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.ActorId","page":"Reference","title":"CircoCore.ActorId","text":"ActorId\n\nA cluster-unique id that is randomly generated when the actor is spawned (first scheduled).\n\nActorId is an alias to UInt64 at the time, so it may pop up in error messages as such.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.Addr","page":"Reference","title":"CircoCore.Addr","text":"Addr(postcode::PostCode, box::ActorId)\nAddr(readable_address::String)\n\nThe full address of an actor.\n\nIf the referenced actor migrates to a different scheduler, messages sent to the old address will bounce back as RecipientMoved and the Addr must be updated manually.\n\nExamples\n\nAddr(\"192.168.1.11:24721\", 0xbc6ac81fc7e4ea2)\n\nAddr(\"192.168.1.11:24721/bc6ac81fc7e4ea2\")\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.Infoton","page":"Reference","title":"CircoCore.Infoton","text":"Infoton(sourcepos::Pos, energy::Real = 1)\n\nCreate an Infoton that carries abs(energy) amount of energy and has the sign sign(energy).\n\nThe infoton mediates the force that awakens between communicating actors. When arriving at its target actor, the infoton pulls/pushes the actor toward/away from its source, depending on its sign (positive pulls).\n\nThe exact details of how the Infoton should act at its target is actively researched. Please check or overload apply_infoton.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.NameQuery","page":"Reference","title":"CircoCore.NameQuery","text":"NameQuery(name::String) <: Request\n\nA query that can be sent to a remote scheduler for querying its local registry.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.Pos","page":"Reference","title":"CircoCore.Pos","text":"Pos(x::Real, y::Real, z::Real)\n\nA point in the 3D \"actor space\".\n\nPos is currently an alias to VecE3{Float32}. See Vec.jl\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.PostCode","page":"Reference","title":"CircoCore.PostCode","text":"PostCode\n\nA string that identifies a scheduler.\n\nExamples\n\n\"192.168.1.11:24721\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.RecipientMoved","page":"Reference","title":"CircoCore.RecipientMoved","text":"RecipientMoved{TBody}\n\nIf a message is undeliverable because the tartget actor moved to a known lcoation, this message will be sent back to the sender. The original message will not be delivered, but it gets included in the RecipientMoved message.\n\nstruct RecipientMoved{TBody}\n    oldaddress::Addr\n    newaddress::Addr\n    originalmessage::TBody\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.addr-Tuple{AbstractActor}","page":"Reference","title":"CircoCore.addr","text":"addr(a::AbstractActor)\n\nReturn the address of the actor.\n\nCall this on a spawned actor to get its address. Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.box-Tuple{Addr}","page":"Reference","title":"CircoCore.box","text":"box(a::Addr)::ActorId\n\nReturn the box of the address, that is the id of the actor.\n\nWhen the actor migrates, its box remains the same, only the PostCode of the address changes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.die-Tuple{ActorService,AbstractActor}","page":"Reference","title":"CircoCore.die","text":"die(service, me::AbstractActor)\n\nUnschedule the actor from its current scheduler.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.getname-Tuple{Any,String}","page":"Reference","title":"CircoCore.getname","text":"function getname(service, name::String)::Union{Addr, Nothing}\n\nReturn the registered name from the scheduler-local registry, or nothing.\n\nSee also: NameQuery\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.id-Tuple{AbstractActor}","page":"Reference","title":"CircoCore.id","text":"id(a::AbstractActor)\n\nReturn the id of the actor.\n\nCall this on a spawned actor to get its id (aka box). Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.migrate-Tuple{ActorService,AbstractActor,String}","page":"Reference","title":"CircoCore.migrate","text":"migrate(service, actor::AbstractActor, topostcode::PostCode)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.onmessage-Tuple{AbstractActor,Any,Any}","page":"Reference","title":"CircoCore.onmessage","text":"onmessage(me::AbstractActor, message, service)\n\nHandle a message arriving at an actor.\n\nOnly the payload of the message is delivered, there is currently no way to access the infoton or the sender address. If you need a reply, include the sender address in the request.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nimport CircoCore.onmessage\n\nstruct TestRequest\n    replyto::Addr\nend\n\nstruct TestResponse end\n\nfunction onmessage(me::MyActor, message::TestRequest, service)\n    send(service, me, message.replyto, TestResponse())\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.onmigrate-Tuple{AbstractActor,Any}","page":"Reference","title":"CircoCore.onmigrate","text":"onmigrate(me::AbstractActor, service)\n\nLifecycle callback that marks a successful migration.\n\nIt is called on the target scheduler, before any messages will be delivered.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nimport CircoCore.onmigrate\n\nfunction onmigrate(me::MyActor, service)\n    println(\"Successfully migrated, registering a name on the new scheduler\")\n    registername(service, \"MyActor\", me)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.onschedule-Tuple{AbstractActor,Any}","page":"Reference","title":"CircoCore.onschedule","text":"CircoCore.onschedule(me::AbstractActor, service)\n\nLifecycle callback that marks the first scheduling of the actor, called during spawning, before any onmessage.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nimport CircoCore.onschedule\n\nfuntion onschedule(me::MyActor, service)\n    registername(service, \"MyActor\", me) # Register this actor in the local name service\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.pos-Tuple{AbstractActor}","page":"Reference","title":"CircoCore.pos","text":"pos(a::AbstractActor)::Pos\n\nreturn the current position of the actor.\n\nCall this on a spawned actor to get its position. Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.redirect-Tuple{Addr,String}","page":"Reference","title":"CircoCore.redirect","text":"redirect(addr::Addr, topostcode::PostCode):Addr\n\nCreate a new Addr by replacing the postcode of the given one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.registername-Tuple{Any,String,AbstractActor}","page":"Reference","title":"CircoCore.registername","text":"registername(service, name::String, actor::AbstractActor)\n\nRegister the given actor under the given name in the scheduler-local name registry.\n\nNote that there is no need to unregister the name when migrating or dying\n\nTODO implement manual and auto-unregistration\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.send-Union{Tuple{TScheduler}, Tuple{TBody}, Tuple{ActorService{TScheduler},AbstractActor,Addr,TBody}, Tuple{ActorService{TScheduler},AbstractActor,Addr,TBody,Real}} where TScheduler where TBody","page":"Reference","title":"CircoCore.send","text":"send(service, sender::AbstractActor, to::Addr, messagebody::Any, energy::Real = 1; timeout::Second = Second(2))\n\nSend a message from an actor to an another.\n\nPart of the actor API, can be called from a lifecycle callback, providing the service you got.\n\nmessagebody can be of any type, but a current limitation of inter-node communication is that the serialized form of messagebody must fit in an IPv4 UDP packet with ~100 bytes margin. The exact value depends on the MTU size of the network and changing implementation details, but 1380 bytes can be considered safe. You may be able to tune your system to get higher values.\n\nIf messagebody is a Request, a timeout will be set for the token of it. The timeout keyword argument can be used to control the deadline.\n\nenergy sets the energy and sign of the Infoton attached to the message.\n\nExamples\n\nconst QUERY = \"The Ultimate Question of Life, The Universe, and Everything.\"\n\nmutable struct MyActor <: AbstractActor\n    searcher::Addr\n    core:: CoreState\n    MyActor() = new()\nend\n\nstruct Start end\n\nstruct Search\n    query::String\nend\n\n[...] # Spawn the searcher or receive its address\n\n\nfunction CircoCore.onmessage(me::MyActor, message::Start, service)\n    send(service,\n            me,\n            me.searcher, \n            Search(QUERY, addr(me)))\nend\n\nImplementation\n\nPlease note that service is always the last argument of lifecycle callbacks like onmessage. It's because onmessage is dynamically dispatched, and service provides no information about where to dispatch. (Only one service instance exists as of v\"0.2.0\")\n\nOn the other hand, actor API endpoints like send are always statically dispatched, thus they can accept the service as their first argument, allowing the user to treat e.g. \"spawn(service\" as a single unit of thought and not forget to write out the meaningless service.\n\nConsistency is just as important as convenience. But performance is king. \n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.spawn-Tuple{ActorService,AbstractActor}","page":"Reference","title":"CircoCore.spawn","text":"spawn(service, actor::AbstractActor, [pos::Pos])::Addr\n\nSpawn the given actor on the scheduler represented by service, return the address of it.\n\nPart of the actor API, can be called from a lifecycle callback, providing the service you got.\n\nThe onschedule callback of actor will run before this function returns.\n\nExamples\n\nmutable struct ListItem{TData} <: AbstractActor\n    data::TData\n    next::Addr\n    core::CoreState\n    ListItem(data) = new{typeof(data)}(data)\nend\n\nstruct Append{TData}\n    value::TData\nend\n\nfunction CircoCore.onmessage(me::ListItem, message::Append, service)\n    me.next = spawn(service, ListItem(message.value))\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.apply_infoton-Tuple{AbstractActor,Infoton}","page":"Reference","title":"CircoCore.apply_infoton","text":"apply_infoton(targetactor::AbstractActor, infoton::Infoton)\n\nAn infoton acting on an actor.\n\nPlease check the source and the examples for more info.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.isbaseaddress-Tuple{Addr}","page":"Reference","title":"CircoCore.isbaseaddress","text":"isbaseaddress(addr::Addr)::Bool\n\nReturn true if addr is a base address, meaning it references a scheduler directly.\n\n\n\n\n\n","category":"method"},{"location":"#Introducing-CircoCore-1","page":"Introducing CircoCore","title":"Introducing CircoCore","text":"","category":"section"},{"location":"#","page":"Introducing CircoCore","title":"Introducing CircoCore","text":"CircoCore is a decentralized actor system that is fast, scalable and extensible.  It features Infoton Optimization, a physics-inspired solution to the data-locality problem.","category":"page"},{"location":"#","page":"Introducing CircoCore","title":"Introducing CircoCore","text":"CircoCore is implemented in Julia - an incredibly fast, dynamic yet compiled language -, and it has a JavaScript sister: CircoCore.js, which can run in the browser and transparently integrate into the CircoCore cluster. These two components form a high performance, distributed application platform.","category":"page"},{"location":"#","page":"Introducing CircoCore","title":"Introducing CircoCore","text":"There is a monitoring tool named \"Camera Diserta\" which can help to tune CircoCore applications and to research Infoton Optimization.","category":"page"},{"location":"#","page":"Introducing CircoCore","title":"Introducing CircoCore","text":"Please note that CircoCore is in alpha stage, it is more like a research tool at the time than a mature platform.","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"When you install & run the system, on http://localhost:8000 soon you will see something like the following:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: The sample loaded in Camera Diserta)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This is the tool \"Camera Diserta\" monitoring the default example: A linked list of 4000 actors, that - when started - will calculate the sum of the list repeatedly.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"6 schedulers are available, but initially all the actors are scheduled on the same one. They will migrate to the other schedulers automatically. Actors are placed in a 3D space randomly - 3D isn't just a fancy visualization trick, but an important element of infoton optimization.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To try out the example, you have to send a \"Run\" message to the test coordinator:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Click \"coordinators\" in the upper left corner to filter only the test coordinator\nClick the coordinator to select it\nThe commands accepted by the coordinator will be queried from it\nClick \"Run\" when it appears\nClick \"all\" to see all the actors again\nWait for the magic to happen\nCheck the logs of the backend to see the speedup","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"After a while Camera Diserta will display something like the following:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Infoton-optimized version of the sample)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Large cuboids are the schedulers (size indicates the number of actors they execute), small cubes packed together are list item actors. Actors are scheduled on the scheduler that is closest in the 3D space.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As you can see, CircoCore's infoton optimization found out the structure of the list without using any \"domain\" knowledge, just by monitoring the communication of actors. It was also able to cut the list into 6 similarly sized segments (5 V-shaped and an I-shaped at the end of the list (bottom)). This solution minimizes the communication between schedulers.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The source code of the sample is at examples/linkedlist.jl.","category":"page"}]
}
